# Description:
#   BUILD rules for generating flatbuffer files in various languages.

"""
Rules for building C++ flatbuffers with Bazel.
"""
DEFAULT_INCLUDE_PATHS = [
    "./",
    "$(GENDIR)",
    "$(BINDIR)",
]

DEFAULT_FLATC_ARGS = [
    "--gen-object-api",
    "--gen-compare",
    "--no-includes",
    "--gen-mutable",
    "--reflect-names",
    "--cpp-ptr-type",
    "flatbuffers::unique_ptr",
]

def _flatbuf_lib_impl(ctx):
    args = ctx.actions.args()
    args.add_all(DEFAULT_FLATC_ARGS)
    args.add(ctx.attr.language_flag)
    args.add("-o", ctx.genfiles_dir.path + "/" + ctx.label.package)
    args.add_all(ctx.files.srcs)

    flatc = ctx.toolchains["//build_tools/toolchain/flatc:toolchain_type"].flatc_executable

    ctx.actions.run(
        inputs = ctx.files.srcs,
        outputs = ctx.outputs.outs,
        tools = [flatc],
        executable = flatc.path,
        arguments = [args],
    )

flatbuffer_library = rule(
    implementation = _flatbuf_lib_impl,
    attrs = {
        "srcs": attr.label_list(mandatory = True, allow_files = True, allow_empty = False),
        "outs": attr.output_list(),
        "language_flag": attr.string(mandatory = True),
    },
    toolchains = ["//build_tools/toolchain/flatc:toolchain_type"],
    output_to_genfiles = True,
)

def flatbuffer_cc_library(name, srcs, outs, **kwargs):
    fbs_name = name + "_cc_srcs"
    flatbuffer_library(
        name = fbs_name,
        outs = outs,
        srcs = srcs,
        language_flag = "--cpp",
    )

    native.cc_library(
        name = name,
        hdrs = [":" + fbs_name],
        srcs = [":" + fbs_name],
        features = ["-parse_headers"],
        deps = ["//third_party/flatbuffers:runtime_cc"],
        linkstatic = True,
        **kwargs
    )

def flatbuffer_java_library(name, srcs, outs, **kwargs):
    fbs_name = name + "_java_srcs"
    flatbuffer_library(
        name = fbs_name,
        outs = outs,
        srcs = srcs,
        language_flag = "--java",
    )

    native.java_library(
        name = name,
        srcs = [":" + fbs_name],
        deps = ["//third_party/flatbuffers:runtime_java"],
        **kwargs
    )

# def flatbuffer_cc_library(
#         name,
#         srcs,
#         srcs_filegroup_name = "",
#         out_prefix = "",
#         includes = [],
#         include_paths = DEFAULT_INCLUDE_PATHS,
#         flatc_args = DEFAULT_FLATC_ARGS,
#         visibility = None,
#         compatible_with = None,
#         restricted_to = None,
#         srcs_filegroup_visibility = None,
#         gen_reflections = False):
#     '''A cc_library with the generated reader/writers for the given flatbuffer definitions.

#     Args:
#       name: Rule name.
#       srcs: Source .fbs files. Sent in order to the compiler.
#       srcs_filegroup_name: Name of the output filegroup that holds srcs. Pass this
#           filegroup into the `includes` parameter of any other
#           flatbuffer_cc_library that depends on this one's schemas.
#       out_prefix: Prepend this path to the front of all generated files. Usually
#           is a directory name.
#       includes: Optional, list of filegroups of schemas that the srcs depend on.
#           ** SEE REMARKS BELOW **
#       include_paths: Optional, list of paths the includes files can be found in.
#       flatc_args: Optional list of additional arguments to pass to flatc
#           (e.g. --gen-mutable).
#       visibility: The visibility of the generated cc_library. By default, use the
#           default visibility of the project.
#       srcs_filegroup_visibility: The visibility of the generated srcs filegroup.
#           By default, use the value of the visibility parameter above.
#       gen_reflections: Optional, if true this will generate the flatbuffer
#         reflection binaries for the schemas.
#       compatible_with: Optional, The list of environments this rule can be built
#         for, in addition to default-supported environments.
#       restricted_to: Optional, The list of environments this rule can be built
#         for, instead of default-supported environments.

#     This produces:
#       filegroup([name]_srcs): all generated .h files.
#       filegroup(srcs_filegroup_name if specified, or [name]_includes if not):
#           Other flatbuffer_cc_library's can pass this in for their `includes`
#           parameter, if they depend on the schemas in this library.
#       Fileset([name]_reflection): (Optional) all generated reflection binaries.
#       cc_library([name]): library with sources and flatbuffers deps.

#     Remarks:
#       ** Because the genrule used to call flatc does not have any trivial way of
#         computing the output list of files transitively generated by includes and
#         --gen-includes (the default) being defined for flatc, the --gen-includes
#         flag will not work as expected. The way around this is to add a dependency
#         to the flatbuffer_cc_library defined alongside the flatc included Fileset.
#         For example you might define:

#         flatbuffer_cc_library(
#             name = "my_fbs",
#             srcs = [ "schemas/foo.fbs" ],
#             includes = [ "//third_party/bazz:bazz_fbs_includes" ],
#         )

#         In which foo.fbs includes a few files from the Fileset defined at
#         //third_party/bazz:bazz_fbs_includes. When compiling the library that
#         includes foo_generated.h, and therefore has my_fbs as a dependency, it
#         will fail to find any of the bazz *_generated.h files unless you also
#         add bazz's flatbuffer_cc_library to your own dependency list, e.g.:

#         cc_library(
#             name = "my_lib",
#             deps = [
#                 ":my_fbs",
#                 "//third_party/bazz:bazz_fbs"
#             ],
#         )

#         Happy dependent Flatbuffering!
#     '''
#     output_headers = [
#         (out_prefix + "%s_generated.h") % (s.replace(".fbs", "").split("/")[-1])
#         for s in srcs
#     ]
#     reflection_name = "%s_reflection" % name if gen_reflections else ""

#     srcs_lib = "%s_srcs" % (name)
#     flatbuffer_library_public(
#         name = srcs_lib,
#         srcs = srcs,
#         outs = output_headers,
#         language_flag = "-c",
#         out_prefix = out_prefix,
#         includes = includes,
#         include_paths = include_paths,
#         flatc_args = flatc_args,
#         compatible_with = compatible_with,
#         restricted_to = restricted_to,
#         reflection_name = reflection_name,
#         reflection_visibility = visibility,
#     )
#     cc_library(
#         name = name,
#         hdrs = [
#             ":" + srcs_lib,
#         ],
#         srcs = [
#             ":" + srcs_lib,
#         ],
#         features = [
#             "-parse_headers",
#         ],
#         deps = [
#             "@com_github_google_flatbuffers//:runtime_cc",
#         ],
#         includes = [],
#         compatible_with = compatible_with,
#         restricted_to = restricted_to,
#         linkstatic = 1,
#         visibility = visibility,
#     )

#     # A filegroup for the `srcs`. That is, all the schema files for this
#     # Flatbuffer set.
#     native.filegroup(
#         name = srcs_filegroup_name if srcs_filegroup_name else "%s_includes" % (name),
#         srcs = srcs,
#         compatible_with = compatible_with,
#         restricted_to = restricted_to,
#         visibility = srcs_filegroup_visibility if srcs_filegroup_visibility != None else visibility,
#     )
